**通过一个案例：**
查询信息从缓存中查询信息，如果缓存中没有则从db查询，再放入缓存中。

这里就会引出一个问题：
```json
|300个客户| -> |服务器| -> 缓存
|300个客户| -> |服务器| -> 缓存        ===>  如果缓存未命中,则访问DB
|300个客户| -> |服务器| -> 缓存
```
在真实的环境中存缓存都会放置过期时间，用来逃脱那些不使用的数据。

在上面示意中，假设 缓存过期时间为 3 秒，那么在第三秒的时候，有900个并发从缓存未命中，那么这个时候，就要从数据库中加载数据，然后set回缓存中。如果不加锁，那么这个时间点到达数据库的并发将是900个，mysql数据库很有可能会挂掉。

## 方法上加锁 synchronized
```java
/**
 * 缓存模拟
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2017/2/8 22:06
 */
public class Cache {
    private Logger log = LoggerFactory.getLogger(getClass());
    private HashMap<String, String> cache = new HashMap<String, String>();

    /**
     * 放置到缓存中
     * @param key
     * @param value
     * @param expire 过期时间3秒
     */
    public void set(String key, String value, int expire) {
        cache.put(key, value);
        // 模拟过期
        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(expire);
                log.info("缓存过期");
                cache.remove(key);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }

    public String get(String key) {
        return cache.get(key);
    }
}

/**
 * 业务类模拟
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2017/2/8 22:42
 */
public class MockService {
    private Logger log = LoggerFactory.getLogger(getClass());
    private Cache cache = new Cache();
    final String code = "book";

    /**
     * 模拟从db查询数据
     * @return
     */
    private Map<Integer, Book> getDBBookMap() {
        //假设业务处理需要时间
        try {
         
/**
 * service 模拟
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2017/2/8 22:42
 */
public class MockService {
    private Logger log = LoggerFactory.getLogger(getClass());
    private Cache cache = new Cache();
    final String code = "book";

    /**
     * 模拟从db查询数据
     * @return
     */
    private Map<Integer, Book> getDBBookMap() {
        //假设业务处理需要时间
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Map<Integer, Book> mockData = new HashMap<>();
        for (int i = 0; i < 10; i++) {
            mockData.put(i, new Book(i, "Java" + i, 100));
        }
        return mockData;
    }

    /**
     * 模拟service 查询数据
     * @return
     */
    public /*synchronized*/ Map<Integer, Book> query() {
        String jsonStr = cache.get(code);
        if (jsonStr != null) {
            log.info("==== Cache Hit");
            return JSON.parseObject(jsonStr, Map.class);
        }
        log.info("==== no Cache");
        // 缓存未命中，则从数据库获取数据
        Map<Integer, Book> dbBookMap = getDBBookMap();
        cache.set(code, JSON.toJSONString(dbBookMap), 2);
        return dbBookMap;
    }
}
```
测试数据类如下：
```java
public class DemoTest {
    private MockService mockService = new MockService();

    /**
     * 普通调用两次，测试数据
     */
    @Test
    public void demo1() {
        mockService.query();
        mockService.query();
    }
    @Test
    public void demo2() {
        // 模拟并发
        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                try {
                    cd2.await(); // 等待发令枪，3个线程就绪后再同时执行该操作
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                mockService.query();
            }).start();
            cd2.countDown();
        }
        synchronized (this) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

demo1输出结果：
23:00:47.777 [main] INFO study001.cache.MockService - ==== no Cache
23:00:48.226 [main] INFO study001.cache.MockService - ==== Cache Hit

因为不是并发，串行执行，所以第二次获取到了。


demo2输出结果：
22:58:18.484 [Thread-1] INFO study001.cache.MockService - ==== no Cache
22:58:18.484 [Thread-0] INFO study001.cache.MockService - ==== no Cache
22:58:18.484 [Thread-2] INFO study001.cache.MockService - ==== no Cache
22:58:20.890 [Thread-5] INFO study001.cache.Cache - 缓存过期
22:58:20.890 [Thread-4] INFO study001.cache.Cache - 缓存过期
22:58:20.890 [Thread-3] INFO study001.cache.Cache - 缓存过期

并发，且没有加锁，都么有查到缓存


在 mockService.quary() 方法上加上锁
public /*synchronized*/ Map<Integer, Book> query() 

demo2输出结果：
23:02:25.958 [Thread-0] INFO study001.cache.MockService - ==== no Cache
23:02:26.420 [Thread-2] INFO study001.cache.MockService - ==== Cache Hit
23:02:26.437 [Thread-1] INFO study001.cache.MockService - ==== Cache Hit
23:02:28.422 [Thread-3] INFO study001.cache.Cache - 缓存过期

貌似达到了效果。但是这种效果就和demo1中的性能差不多了。性能会非常差。
```

## 同步代码块





