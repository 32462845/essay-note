# 重构注册逻辑

在浏览器中的第三方登录回顾：

1. social 在拿到用户信息之后
2. 查询数据库没有绑定的用户会跳转到默认的/signUp路径
3. 提供了一个我们自己的注册页面，拿到用户提交的注册信息，调用social数据库服务，把关联信息写入数据库中。完成注册
4. 再次登录，数据库中有用户信息，则登录成功

问题：
1. 上面这个流程问题所在就是 第三方的信息存放在了 session 中；
2. 还有一个问题，就是第2步会302.需要客户端信息判定并跳转到登录页

所以现在开始改造，改造方案：

1. 流程完成后，更改跳转的页面到app指定页面，
2. 根据设备id，我们把信息存放在redis中
2. 用户注册完成后，提交，再把第三方信息拿出来，合并完成注册

## 改造
> 注意： 在改造测试之前把默认注册用户的功能关闭掉
> 也就是 com.example.demo.security.DemoConnectionSignUp 类


之前的注册地址是在
```java
cn.mrcode.imooc.springsecurity.securitycore.social.SpringSocialConfig#imoocSocialSecurityConfig

@Bean
public SpringSocialConfigurer imoocSocialSecurityConfig() {
    // 默认配置类，进行组件的组装
    // 包括了过滤器SocialAuthenticationFilter 添加到security过滤链中
    MySpringSocialConfigurer springSocialConfigurer = new MySpringSocialConfigurer();
    springSocialConfigurer.signupUrl(securityProperties.getBrowser().getSignUpUrl());
    springSocialConfigurer.setSocialAuthenticationFilterPostProcessor(socialAuthenticationFilterPostProcessor);
    return springSocialConfigurer;
}
```
中设置的，那么先把这个地址更改掉，由于这里在浏览器环境下工作得很好，不要直接修改这里。使用一个技巧替换掉

```java
package cn.mrcode.imooc.springsecurity.securityapp;

import cn.mrcode.imooc.springsecurity.securitycore.social.SpringSocialConfig;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.social.security.SpringSocialConfigurer;
import org.springframework.stereotype.Component;

/**
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2018/8/8 23:49
 */
@Component
public class SpringSocialConfigurerPostProcessor implements BeanPostProcessor {
    // 任何bean初始化回调之前
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

    //任何bean初始化回调之后
    // 在这里把之前浏览器中配置的注册地址更改为app中的处理控制器
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        /**
         * @see SpringSocialConfig#imoocSocialSecurityConfig()
         */
        if (beanName.equals("imoocSocialSecurityConfig")) {
            SpringSocialConfigurer config = (SpringSocialConfigurer) bean;
            config.signupUrl("/social/signUp");
            return bean;
        }
        return bean;
    }
}

```

编写处理跳转接收的控制器;用户把信息传递给前段，引用用户注册；

这里的流程还是之前的拿到code，带着client获得我们系统的accessToken信息

由于数据库中没有该openid的用户信息，所以是未授权状态。

这里先简单写下，然后测试看是否能跳转到这里来。是否能从session中获取到第三方信息；

```java
package cn.mrcode.imooc.springsecurity.securityapp;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.social.connect.Connection;
import org.springframework.social.connect.web.ProviderSignInUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.request.ServletWebRequest;

import javax.servlet.http.HttpServletRequest;

/**
 * 处理登录的控制器
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2018/8/8 23:56
 */
@RestController
public class AppSecurityController {
    private Logger logger = LoggerFactory.getLogger(getClass());
    @Autowired
    private ProviderSignInUtils providerSignInUtils;

    @GetMapping(value = "/social/signUp")
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public Connection signUp(HttpServletRequest request) {
        Connection<?> connectionFromSession = providerSignInUtils.getConnectionFromSession(new ServletWebRequest(request));
        logger.info(ReflectionToStringBuilder.toString(connectionFromSession, ToStringStyle.JSON_STYLE));
        return connectionFromSession;
    }
}

```

我使用postman，跟踪源码的确是走了Redirect;但是postman里面没有302状态，
直接走到上面的控制器里面去了。。搞不明白啊；

一直有一个疑惑，不是说app没有session吗？302的话相当于ajax响应。再次发起请求不是同一个session了，怎么拿到信息的呢？
```java
// connection unknown, register new user?
    if (signupUrl != null) {
      // store ConnectionData in session and redirect to register page
      sessionStrategy.setAttribute(new ServletWebRequest(request), ProviderSignInAttempt.SESSION_ATTRIBUTE, new ProviderSignInAttempt(token.getConnection()));
      throw new SocialAuthenticationRedirectException(buildSignupUrl(request));
    }
```
