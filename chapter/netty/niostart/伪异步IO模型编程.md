# 伪异步I/O模型编程

传统的BIO编程，一线程对应一客户端，如果海量链接接入，系统资源将会耗尽

伪异步也就是 使用线程池，把多线程交给线程池来改进性能。使用有有界线程池

## 弊端分析(也是同步阻塞的弊端吧？)

通过api分析
### read(byte b[])
`public int read(byte b[]) throws IOException `

api 描述中说道：该方法会阻塞，以下几种情况例外：
- 有数据可读
- io异常
- 可用数据已经读取完毕(在sock中根本就不知道是否已经读取完毕)

### write
`public void write(byte b[]) throws IOException `

会阻塞，直到所有要发送的字节写入完毕，或则发生异常。

`注：`TCP/IP 相关知识 Keep-Alive 装，会导致无限阻塞或阻塞时间过长

### 一些弊端出现
- 服务器处理缓慢，应答消息耗时长
- 读取有故障节点的客户端
- 如所有可用线程都被使用，那么后续线程将被排队
- 线程池采用阻塞队列实现，当队列满之后，后续入队列操作也将阻塞
- 目前只有一个`server.accept()`接入客户端，如果该操作被同步阻塞到了 入队列操作中的话，那么就会导致后续请求者全部超时

这样一来大部分客户端都会链接超时。一般都会认为系统已经崩溃。