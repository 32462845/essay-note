# TCP粘包/拆包的基础知识
`TCP`是个流协议（没有界限的一串数据）.底层并不了解上层业务数据,`TCP`会根据自身的缓冲区的实际情况进行包的划分。所以就有可能出现`粘包/拆包`问题;

## 粘包
假设我们需要发送3次1 -> 服务器,理想中，服务器应该接收到3次1.
但是实际上有可能会一次接到`111`.这就是粘包。

## 拆包
假设我们发送很3条大数据`123456789`，理想中，服务器应该接收到3次`123456789`.
但是实际情况上有可能只接到2次,一次接到`123456789123`,一次接到`456789`,这就是拆包。

## TCP粘包/拆包发生的原因
1. 应用程序write写入的自己大小大于套接接口发送缓冲区大小
2. 进行MSS大小的TCP分段
3. 以太网的帧 `payload`大于`MTU`进行IP分片
![](/assets/netty-niostart-nio-粘包拆包原因.jpg)

## 粘包问题的解决策略
底层无法保证数据包的完整性，那么就通过上层应用协议栈来解决。主流的解决方案有：
1. 消息定长。如：每个报文的大小为固定长度200字节，如果不够，空位补空格
2. 在包尾增加回车换行符进行分割. 如：FTP协议
3. 将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常设计思路为消息头的第一个字段使用int32来标识消息的总长度。
4. 更复杂的应用层协议。

# 不考虑粘包/拆包案例
直接拿上面的入门例子改造。改造思路很简单。
1. 在服务端统计下 读取的次数
2. 在客户端连续发送100次
```java

        /**
         * 客户端和服务端TCP链路建立成功之后，该方法被调用
         * @param ctx
         * @throws Exception
         */
        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            // 主要更改这里。连续发送100条消息
            for (int i = 0; i < 100; i++) {
                firstMessage = Unpooled.buffer(req.length);
                firstMessage.writeBytes(req);
                ctx.writeAndFlush(firstMessage);
            }
        }
```

运行之后你会发现：（每个人的机器上测试的不同）
1. 服务端只接收了5次，且每一次的信息 是好几条的合集，而且还有不完整的句子（中途被截断那种）
2. 客户端只接收了一次。

明显的出现了问题。我们需要的是发送100次就接收100次
# 使用Netty解决半包问题
首先我们要定制一个规则，在每行消息后面添加换行符。 再使用Netty提供的解决策略来解决。
```java
+ System.getProperty("line.separator");  //使用系统换行符

// 刚才有粘包问题的加上换上符号结果也是一样的。
```
