# TCP粘包/拆包的基础知识
`TCP`是个流协议（没有界限的一串数据）.底层并不了解上层业务数据,`TCP`会根据自身的缓冲区的实际情况进行包的划分。所以就有可能出现`粘包/拆包`问题;

## 粘包
假设我们需要发送3次1 -> 服务器,理想中，服务器应该接收到3次1.
但是实际上有可能会一次接到`111`.这就是粘包。

## 拆包
假设我们发送很3条大数据`123456789`，理想中，服务器应该接收到3次`123456789`.
但是实际情况上有可能只接到2次,一次接到`123456789123`,一次接到`456789`,这就是拆包。

## TCP粘包/拆包发生的原因
1. 应用程序write写入的自己大小大于套接接口发送缓冲区大小
2. 进行MSS大小的TCP分段
3. 以太网的帧 `payload`大于`MTU`进行IP分片
![](/assets/netty-niostart-nio-粘包拆包原因.jpg)

## 粘包问题的解决策略
底层无法保证数据包的完整性，那么就通过上层应用协议栈来解决。主流的解决方案有：
1. 消息定长。如：每个报文的大小为固定长度200字节，如果不够，空位补空格
2. 在包尾增加回车换行符进行分割. 如：FTP协议
3. 将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常设计思路为消息头的第一个字段使用int32来标识消息的总长度。
4. 更复杂的应用层协议。

# 不考虑粘包/拆包案例

# 使用Netty解决半包问题